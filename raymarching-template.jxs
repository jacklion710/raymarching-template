<jittershader name="Raymarching Template">
<description>Raymarching Template</description>

<param name="modelViewProjectionMatrix" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
<param name="position" type="vec3" state="POSITION" />
<param name="texcoord" type="vec2" state="TEXCOORD" />
<param name="viewport" type="vec2" state="VIEWPORT" />
<param name="lightPos" type="vec3" default="0.1, 3.0, -5.0" />
<param name="camPos" type="vec3" state="CAMERA_POSITION" />

<param name="iTime" type="float" default="0.0" />
<param name="iResolution" type="vec2" state="RESOLUTION" />

<language name="glsl" version="1.5">

<bind param="modelViewProjectionMatrix" program="vp" />
<bind param="position" program="vp" />
<bind param="texcoord" program="vp" />
<bind param="viewport" program="vp" />
<bind param="lightPos" program="fp" />
<bind param="camPos" program="fp" />

<bind param="iTime" program="fp" />
<bind param="iResolution" program="fp" />

<include source="globals.glsl" program="fp" />
<include source="sdf.glsl" program="fp" />
<include source="domain-repetition.glsl" program="fp" />
<include source="lighting.glsl" program="fp" />
<include source="marching-engine.glsl" program="fp" />

<program name="vp" type="vertex"  >
<![CDATA[
#version 330 core

in vec3 position;
in vec2 texcoord;
in vec2 viewport;
out jit_PerVertex {
	vec2 texcoord;
} jit_out;
uniform mat4 modelViewProjectionMatrix;

void main(void) {
	gl_Position = modelViewProjectionMatrix*vec4(position, 1.);
	float aspectRatio = 1280.0 / 720.0; // viewport.x / viewport.y;
	jit_out.texcoord = texcoord - 0.5;
	jit_out.texcoord.x *= aspectRatio;
}
]]>
</program>
		
<program name="fp" type="fragment"  >
<![CDATA[
#version 330 core

in jit_PerVertex {
	vec2 texcoord;
} jit_in;
layout (location = 0) out vec4 outColor;

void main(void) {
	// Ray origin (camera position)
	vec3 ro = camPos;

	// Target point
	vec3 ta = vec3(0.0);
	mat3 camMat = getCameraMatrix(ro, ta);
	
	// Ray direction
	float planeDist = 0.6; // Distance to the plane
	vec3 rd = normalize(camMat * vec3(jit_in.texcoord, planeDist));
	
	// Raymarching
	float dist = map(ro, rd);

	// Output color
	vec3 col;
	vec3 bgCol = vec3(0.0);

	// Color the scene based on the distance to the object
	col = (dist > MAX_DIST) ? bgCol : getLight(ro + rd * dist, rd);

	// Output the color
	outColor = vec4(col, 1.0);
}
]]>
</program>
</language>
</jittershader>
