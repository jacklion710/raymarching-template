<jittershader name="Raymarching Template">
<description>Raymarching Template</description>

<param name="modelViewProjectionMatrix" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
<param name="position" type="vec3" state="POSITION" />
<param name="texcoord" type="vec2" state="TEXCOORD" />
<param name="viewport" type="vec2" state="VIEWPORT" />
<param name="lightPos" type="vec3" default="0.1, 3.0, -5.0" />
<param name="camPos" type="vec3" state="CAMERA_POSITION" />

<param name="iTime" type="float" default="0.0" />
<param name="iResolution" type="vec2" state="RESOLUTION" />

<language name="glsl" version="1.5">

<bind param="modelViewProjectionMatrix" program="vp" />
<bind param="position" program="vp" />
<bind param="texcoord" program="vp" />
<bind param="viewport" program="vp" />
<bind param="lightPos" program="fp" />
<bind param="camPos" program="fp" />

<bind param="iTime" program="fp" />
<bind param="iResolution" program="fp" />

<program name="vp" type="vertex"  >
<![CDATA[
#version 330 core

in vec3 position;
in vec2 texcoord;
in vec2 viewport;
out jit_PerVertex {
	vec2 texcoord;
} jit_out;
uniform mat4 modelViewProjectionMatrix;

void main(void) {
	gl_Position = modelViewProjectionMatrix*vec4(position, 1.);
	float aspectRatio = 1280.0 / 720.0; // viewport.x / viewport.y;
	jit_out.texcoord = texcoord - 0.5;
	jit_out.texcoord.x *= aspectRatio;
}
]]>
</program>
		
<program name="fp" type="fragment"  >
<![CDATA[
#version 330 core
#define MAX_STEPS 100
#define MIN_DIST 0.0001
#define MAX_DIST 100.0

in jit_PerVertex {
	vec2 texcoord;
} jit_in;
layout (location = 0) out vec4 outColor;

uniform float iTime;
uniform vec2 iResolution;
uniform vec3 lightPos;
uniform vec3 camPos;

// SDF Functions

float SDFsphere(vec3 pos, vec3 c, float ra){
	return length(pos - c) - ra;
}

float SDFbox(vec3 pos, vec3 c, vec3 ra){
	vec3 d = abs(pos + c) - ra;
	return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// If only three arguments are provided, origin is assumed to be vec3(0).
vec3 opRepeatFinite(vec3 p, vec3 cellSize, vec3 halfCount, vec3 origin) {
    vec3 q = p - origin;
    vec3 cellIndex = clamp(round(q / cellSize), -halfCount, halfCount);
    return q - cellSize * cellIndex + origin;
}

float getDist(vec3 pos){ // Compose your scene herex
	// Repeated object settings
	vec3 repeatCellSize = vec3(0.3);
	vec3 repeatHalfCount = vec3(1.0, 0.0, 1.0);

	// Apply finite repetition ONLY to the box's local sample position.
	vec3 qBox = opRepeatFinite(pos, repeatCellSize, repeatHalfCount, vec3(0.0));
	return SDFbox(qBox, vec3(0.0), vec3(0.1)) - 0.01;
}

float map(vec3 ro, vec3 rd){ // Raymarching loop
	float hitMap;
	float currDist = 0;
	float dist = 0;
	vec3 pos;
	for(int i = 0; i < MAX_STEPS; i++) {
		pos = ro + rd * currDist;
		dist = getDist(pos);
		currDist += dist;
		hitMap = i / MAX_STEPS - 1.0;
		if(dist < MIN_DIST || currDist > MAX_DIST){
			break;
		}
	}
	return currDist;
}

vec3 getNorm(vec3 hitPos){ // Normal calculation for lighting
	vec2 eps = vec2(0.00001, 0.0);
	float shiftX = getDist(hitPos + eps.xyy) - getDist(hitPos - eps.xyy);
	float shiftY = getDist(hitPos + eps.yxy) - getDist(hitPos - eps.yxy);
	float shiftZ = getDist(hitPos + eps.yyx) - getDist(hitPos - eps.yyx);
	return normalize(vec3(shiftX, shiftY, shiftZ));
}

vec3 getLight(vec3 hitPos, vec3 rd){ // Lighting calculation
	vec3 normals = getNorm(hitPos);
	vec3 lightDir = normalize(hitPos - lightPos);
	float direct = max(-dot(lightDir, normals), 0.0);
	
	vec3 refRd = reflect(rd, normals);
	float reflected = max(-dot(lightDir, refRd), 0.0);

	reflected = pow(reflected, 100);

	vec3 ambient = vec3(0.1);
	vec3 col = vec3(direct + reflected) + ambient;
	return col;
}

mat3 getCameraMatrix(vec3 ro, vec3 ta){
	vec3 a = normalize(ta - ro);
	vec3 b = cross(a, vec3(0.0, 1.0, 0.0));
	vec3 c = cross(b, a);
	return mat3(b, c, a);
}

void main(void) {
	// Ray origin (camera position)
	vec3 ro = camPos;

	// Target point
	vec3 ta = vec3(0.0);
	mat3 camMat = getCameraMatrix(ro, ta);
	
	// Ray direction
	float planeDist = 0.6; // Distance to the plane
	vec3 rd = normalize(camMat * vec3(jit_in.texcoord, planeDist));
	
	// Raymarching
	float dist = map(ro, rd);

	// Output color
	vec3 col;
	vec3 bgCol = vec3(0.0);

	// Color the scene based on the distance to the object
	col = (dist > MAX_DIST) ? bgCol : getLight(ro + rd * dist, rd);

	// Output the color
	outColor = vec4(col, 1.0);
}
]]>
</program>
</language>
</jittershader>
